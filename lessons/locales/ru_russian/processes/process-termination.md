# Прекращение процесса

## Содержание урока

Теперь, когда мы знаем, что происходит, когда процесс создается, что происходит, когда нам это больше не нужно? Будьте осторожны, иногда Linux может быть немного злостнее ...

Процесс может быть окончен из системного вызова _exit, это освободит ресурсы, которые этот процесс использовал для перераспределения. Поэтому, когда процесс готов к завершению, он дает возможность ядру знать, почему он заканчивается со определенным статусом завершения. Чаще всего статус 0 означает, что процесс выполнен успешно. Однако этого недостаточно для полного прекращения процесса. Родительский процесс должен подтвердить завершение дочернего процесса с помощью системного вызова wait. Это значит, что он проверяет состояние завершения дочернего процесса. Я знаю, что об этом ужасно думать, но вызов wait - необходимость, ведь какой родитель не хотел бы знать, как умер его ребенок?

Существует еще один способ прекратить процесс, который включает в себя использование сигналов, которые мы обсудим в ближайшее время.

<b>Процессы-сироты</b>

Когда родительский процесс умирает до дочернего процесса, ядро знает, что оно не получит вызов ожидания, поэтому вместо этого он делает эти процессы «сиротами» и ставит их под опеку init (вспомните мать всех процессов). Init в конечном итоге выполнит системный вызов wait для этих сирот, чтобы они могли быть завершены.

<b>Процессы-зомби</b>

Что происходит, когда дочерний процесс завершается, а родительский процесс еще не вызвал wait? Мы по-прежнему хотим видеть, как завершается дочерний процесс, поэтому, даже если дочерний процесс завершен, ядро превращает дочерний процесс в процесс-зомби. Ресурсы, используемые дочерним процессом, по-прежнему освобождаются для других процессов, однако в таблице процессов для этого зомби еще есть запись. Процессы-зомби также не могут быть убиты, так как они технически «мертвы», поэтому вы не можете использовать сигналы, чтобы их убить. В конце концов, если родительский процесс вызывает системный вызов wait, зомби исчезнет, это называется «reaping». Если родитель не выполняет вызов wait, init примет зомби и автоматически выполнит wait и удалит зомби. Это может быть плохо, если у вас слишком много зомбированных процессов, так как они занимают место в таблице процессов, если они заполняются, это приостановит запуск других процессов.

## Задание

Нет задания для этого урока.

## Вопрос

Каков наиболее распростроненный статус завершения успешного процесса?

## Ответ

0