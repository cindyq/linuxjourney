# Создание процессов

## Содержание урока

Опять же, этот урок и следующий - это просто информация, позволяющая вам видеть, что происходит внутри вашего ПК, не стесняйтесь возвращаться к этому уроку, как только вы что нибудь призабудите.

Когда создается новый процесс, существующий процесс обычно клонирует себя с помощью так называемого системного вызова fork (системные вызовы будут обсуждаться позже в будущем). Системный вызов fork создает идентичный дочерний процесс, этот дочерний процесс принимает новый идентификатор процесса (PID), а исходный процесс становится его родительским процессом и имеет то, что называется идентификатором родительского процесса <b>PPID</b>. Впоследствии дочерний процесс может либо продолжать использовать ту же программу, которую его родитель использовал до или чаще всего используется системный вызов execve для запуска новой программы. Этот системный вызов уничтожает управление памятью, которое ядро создает для этого процесса и устанавливает новые для новой программы.

Мы можем увидеть это в действии:

<pre>$ ps l</pre>

Опция l дает нам «длинный формат» или более подробный обзор наших запущенных процессов. Вы увидите столбец с меткой <b>PPID</b>, это родительский идентификатор. Теперь посмотрите на свой терминал, вы увидите процесс, который является вашей оболочкой, поэтому в моей системе у меня есть процесс, выполняющий bash. Теперь помните, когда вы запускали команду ps l, вы запускали ее из процесса, который выполнял bash. Теперь вы увидите, что <b>PID</b> оболочки bash является <b>PPID</b> команды <b>ps l</b>.

Так что, если у каждого процесса должен быть родительский элемент, а они просто fork друг друга, должна быть мать всех процессов, правильно? Вы правы, когда система загружается, ядра создают процесс с именем <b>init</b>, у него есть PID равный 1. Процесс init не может быть завершен, пока система не выключится. Он работает с привилегиями root и запускает множество процессов, которые поддерживают работу системы. Мы более подробно рассмотрим init в процессе загрузки системы, а теперь мы просто будем знать, что это процесс, порождающий все другие процессы.

## Задание

Взгляните на свои запущенные процессы, можете ли вы увидеть, какие другие процессы имеют родительский процесс?

## Вопрос

Какой системный вызов создает новый процесс?

## Ответ

fork
